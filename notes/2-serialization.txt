Serialization
сериализация - мост между структурами языка и байтами на диске.
Например есть структура:
```
Entry {
  key: [байты]
  val: [байты]
}
```
её нужно превратить в один непрерывный массив байт, чтобы:
- записать в файл
- отправить по сети
- восстановить обратно (decode позже)
---
Формат:
```
| key_len | val_len | key bytes | val bytes |
| 4 байта | 4 байта |    ...    |    ...    |
```
- key_len -  длина ключа (u32, little-endian)
- val_len - длина значения (u32, little-endian)
- дальше сырые байты, без нулей, без терминаторов
---
Пример
```
key = "a"  -> [0x61]
val = "bb" -> [0x62, 0x62]
```
```
key_len = 1 -> 01 00 00 00
val_len = 2 -> 02 00 00 00
```
Итог:
```
[01 00 00 00 | 02 00 00 00 | 61 | 62 62]
```
---
Размер пишется первым потому что:
- байты — это просто поток
- без размера не понятно, где заканчивается ключ
---
Endian — это порядок байтов в числе, которое занимает больше 1 байта.
Возьмём число: 0x12345678   (32-битное число)
Оно состоит из байтов:  12 34 56 78
Вопрос: какой байт идёт первым в памяти?
1. Little-endian (младший первым) 78 56 34 12
2. Big-endian (старший первым) 12 34 56 78
(история про то с какой стороны разбивать яйцо)
В Rust:
len.to_le_bytes()
буквально - Запиши число в little-endian, независимо от платформы
Обратная операция при чтении будет:
u32::from_le_bytes([b0, b1, b2, b3])
---
```rust
Vec::with_capacity(total_size)
```
- заранее резервируем память
---
```rust
data.extend_from_slice(&self.key);
```
- копирует байты
- быстрее и чище, чем push в цикле
---
Почему Vec<u8>, а не &[u8]
Entry владеет данными, а сериализация не должна зависеть от внешней памяти
=====