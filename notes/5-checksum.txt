Неполные записи(защита от torn write)
При добавлении записи в журнал мы хотим, чтобы она была либо полностью записана, либо не записана вообще. Это называется атомарностью. Неполные записи известны как порванные записи
Запись в файл не гарантирует атомарность в случае отключения питания.
Добавленные данные не только не атомарны, но даже размер файла может быть некорректным
===
Атомарность при записи на диск
Центральный процессор обеспечивает атомарные операции чтения/записи в память, которые обрабатывают данные размером с целое число. 
На аппаратном уровне запись одного сектора, вероятно, является атомарной. Сектор — это наименьшая единица чтения/записи на диск, обычно 512 байт или 4 КБ.
Многие программные системы полагаются на атомарность на уровне сектора для достижения атомарности в более крупных масштабах. Например, при записи журнала можно зарезервировать сектор в начале журнала для хранения позиции последней записи журнала. После успешной синхронизации журнала с помощью fsync сектор обновляется (включая синхронизацию этого сектора). Это обеспечивает атомарность для всего журнала.
Даже без атомарности на аппаратном уровне программное обеспечение может достичь атомарности без необходимости двух синхронизаций fsync.
===
Контрольная сумма
Если мы можем обнаружить неполную запись, мы можем просто игнорировать её. Последняя затронутая запись будет той, которая предшествует последней успешной операции fsync.
Контрольная сумма — это хеш, и разные данные будут иметь разные контрольные суммы. 
---
запись в WAL:
- либо полностью валидна
- либо игнорируется целиком
при крэше:
- все записи до последнего fsync применяются
- последняя (порванная) запись не ломает восстановление
НЕ пытаемся чинить повреждённые записи в середине
просто обрезаем лог по последней корректной записи

Новый формат записи Entry(добавлена контролная сумма):
| crc32   | размер ключа | размер значения | удаленные данные | данные ключа |
| 4 байта | 4 байта      | 4 байта         | 1 байт | ... | ... |
crc считается по всем полям КРОМЕ самой crc
crc пишется в начале
если crc не сходится - запись порвана или битая
---
Ошибки обрабатвать в Log read:
Err(e) if e.kind() == io::ErrorKind::UnexpectedEof => Ok(None),
Err(e) if e.kind() == io::ErrorKind::InvalidData => Ok(None),
и в Еntry Decode:
if actual_crc != expected_crc {
    return Err(Error::new(ErrorKind::InvalidData, "bad checksum"));
}
---
Реализация crc32 для вычисления контрольной суммы
cargo add crc32fast
---
Исправляем Entry Encode и Decode:
- сериализуем всё без crc
- считаем crc
- пишем crc + payload
---

===
Rust io::read_exact
Интерфейс io::read позволяет возвращать меньшее количество байтов, чем запрошенная длина буфера. Например, запрос 4 байтов может вернуть только 3, но это не означает конец данных (eof). Хотя это обычно не происходит при чтении из файла, это распространенная ситуация с источниками, такими как TCP-сокеты. Поэтому при использовании io::read следует зацикливаться до тех пор, пока количество возвращаемых байтов не будет соответствовать размеру буфера. Метод io::read_exact из стандартной библиотеки может заменить этот цикл:
===
Использование контрольных сумм
Помимо неполных записей, контрольные суммы также могут обнаруживать повреждение данных, вызванное аппаратными сбоями, такими как искажение битов из-за ошибок диска или памяти. Это редкое явление, возникающее при работе с обычным оборудованием. Однако это не является целью использования контрольных сумм в базах данных, поскольку базы данных не могут восстановиться после таких скрытых потерь данных. Если запись в середине журнала повреждена, невозможно узнать, существуют ли последующие записи.
В качестве контрольных сумм также можно использовать криптографические хеш-функции (например, sha256 или md5).
Однако нет причин их использовать, поскольку специализированные функции контрольных сумм
меньше и быстрее. Даже простые методы проверки контрольных сумм, такие как 16-битная целочисленная сумма, используемая в TCP/IP, достаточны. Однако следует проявлять осторожность в случае, когда все байты равны 0. В таких случаях контрольная сумма не должна быть равна 0, и crc32 не имеет этой проблемы.
===
Краткое описание
Благодаря логам + контрольным суммам + fsync база данных может восстановиться после отключения питания и гарантировать, что ранее успешные записи не будут потеряны
======

