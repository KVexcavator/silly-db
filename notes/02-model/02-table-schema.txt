Структуры
Название таблицы, названия столбцов, типы столбцов, первичный ключ:
```rust
use crate::model::data_types::CellType; // переименовывал из Cell

#[derive(Debug, Clone, PartialEq)]
pub struct Schema {
    pub table: String,
    pub cols: Vec<Column>,
    pub pkey: Vec<usize>, // indexes of columns
}

#[derive(Debug, Clone, PartialEq)]
pub struct Column {
    pub name: String,
    pub data_types: CellType,
}
```
Например, вот эта таблица:
```
create table `link` (
    `time` int64 not null,
    `src` string not null,
    `dst` string not null,
    primary key (`src`, `dst`)
);
```
Представлено в следующем виде:
```
schema := &Schema{
Table: "link",
    Cols: []Column{
        {Name: "time", Type: TypeI64},
        {Name: "src", Type: TypeStr},
        {Name: "dst", Type: TypeStr},
    },
    PKey: []int{1, 2}, // (src, dst)
}
```
---
Первичный ключ
Первичный ключ — это уникальный идентификатор строки. Он состоит из одного или нескольких столбцов. Для работы со строкой необходимо сначала найти её по первичному ключу. Таким образом, первичный ключ — это Key в KeyValue, а столбцы, не являющиеся первичным ключом, хранятся в V. Это позволяет хранилищу KV реализовать реляционную базу данных (типа OLTP).
Помимо первичных ключей, индексы также строятся на основе KeyValue. Индекс позволяет найти первичный ключ Kye, а затем использовать его для получения Value. Как в книге: номер страницы — это первичный ключ, а «оглавление» и «индекс» — это индексы. Они помогают найти номер страницы, а затем и содержимое. В некоторых случаях индекс уже содержит достаточно данных, поэтому V не нужно читать, например, только оглавление.
И первичные ключи, и индексы являются KeyValue. Разница в том, что первичный ключ необходим.
Поэтому индексы также называются вторичными индексами, а первичный ключ — первичным ключом.
Некоторые базы данных, например SQLite, допускают наличие таблиц без определяемого пользователем первичного ключа.
Это связано с тем, что таблицы SQLite имеют скрытый автоматически генерируемый первичный ключ.
Видимые пользователю первичные ключи — это обычные индексы, и между первичным и вторичным ключом нет существенной разницы.
---
Кодирование строки(row) как key-value
Строка в базе данных представляется следующим образом:
```rust
use crate::model::data_types::{CellType, DecodeError};

#[derive(Debug, Clone, PartialEq)]
pub struct Row {
    pub cells: Vec<Cell>,
}

impl Schema {
    pub fn new_row(&self) -> Row {
        self.cols
            .iter()
            .map(|col| match col.data_type {
                Cell::I64(_) => Cell::I64(0),
                Cell::Str(_) => Cell::Str(Vec::new()),
            })
            .collect()
    }
}
```
Метод Schema::new_row() возвращает строку нужного размера, но не инициализированную.
Cериализацию и десериализацию для Row:
```
fn encode_key(&self, schema: &Schema) -> Vec<u8>
fn decode_key(
        &mut self,
        schema: &Schema,
        mut key: &[u8],
    ) -> Result<(), DecodeError>
fn encode_val(&self, schema: &Schema) -> Vec<u8>
fn decode_val(
        &mut self,
        schema: &Schema,
        mut val: &[u8],
    ) -> Result<(), DecodeError>
```
Требования:
- входные или выходные строки должны соответствовать схеме
- применены методы CellType::encode() и CellType::decode() из data-types
- соблюается порядок столбцов, определенный в схеме
---
Key Prefix
В базе данных много таблиц, поэтому для различения таблиц закодированным ключам необходим префикс. Мы будем использовать:
имя таблицы:
```
fn encode_key(&self, schema: &Schema) -> Vec<u8> { ...

    key.extend_from_slice(schema.table.as_bytes());
    key.push(0x00);
```
После имени таблицы добавляется разделитель 0x00, чтобы избежать конфликтов ключей из-за префиксов имен.
Например, имена таблиц ab и abc имеют префиксы "ab\x00" и "abc\x00".
На практике в качестве префикса можно присвоить целочисленный идентификатор. Это экономит место и позволяет переименовывать таблицы.
===