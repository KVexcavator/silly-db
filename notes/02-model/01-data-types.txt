Union
На этом шаге начинается использование ключевого слова key-value для построения реляционной базы данных. Как и в Excel, одна база данных может содержать множество таблиц.
Таблица имеет строки и столбцы. Каждый столбец может выбирать тип данных, в отличие от ключевого слова key-value, которое поддерживает только строки/байты. Мы реализуем 2 типа данных: int64 и []byte.
В Rust настоящий union — это enum.
Ячейка представляет различные типы данных. Различаются по типу: данные могут быть либо I64, либо Str
---
Serialization
Требования:
- Cell::encode_into() добавляет сериализованный результат к входному срезу. При сериализации строки next несколько значений Cell будут объединены. Один и тот же срез можно использовать повторно, чтобы избежать повторного выделения памяти.
ничего не аллоцирует, можно энкодить цепочкой:
```rust
cell1.encode_into(&mut buf);
cell2.encode_into(&mut buf);
```
- Cell::decode() десериализует данные из входного среза и возвращает оставшиеся данные.
- int64 использует binary. Little Endian. []byte использует следующий формат:
```
| type | payload |
| 1b   | ...     |
```
payload:
I64 - 8 bytes little-endian
Str - u32(len) little-endian + bytes
---
Endianness(порядок байтов)
При записи числа на бумаге младшие цифры находятся справа, а старшие — слева.
При записи массива элемент 0 находится слева, а старшие адреса памяти — справа. Это различие приводит к использованию порядка байтов big endian и little endian.
32-битное целое число в регистре ЦП — это всего лишь 32 бита. При хранении в памяти оно группируется в 4 байта. Если байты следуют естественному порядку (младшие биты в байте 0, старшие биты в байте 3), это порядок little endian. Если они следуют порядку записи (младшие биты в байте 3, старшие биты в байте 0), это порядок big endian.
Например, 0x11223344 в шестнадцатеричном формате: little endian — это 44 33 22 11, big endian — это 11 22 33 44.
Исторически некоторые компьютеры использовали порядок big endian. Именно поэтому многие сетевые протоколы, такие как TCP/IP, используют порядок big endian. Сегодня доминирует порядок байтов little endian. Процессору, работающему с little endian, приходится преобразовывать данные в формате big endian, что увеличивает объем работы. Новые форматы данных и протоколы в основном используют little endian.
Формат big endian по-прежнему имеет особое применение (сортировка), которое появится позже.
little-endian совпадает с Rust to_le_bytes()
---
Знаковые и беззнаковые целые числа
let x: i64 = -1;
let u = x as u64; // 18446744073709551615
let y = u as i64; // -1
---
Знаковый бит
Старший бит знакового целого числа показывает, отрицательное оно или нет. 
Если бы использовался знак + абсолютное значение, существовали бы как +0, так и −0, которые существуют только в числах с плавающей запятой, а не в целых числах.


