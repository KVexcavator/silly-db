WAL — Write-Ahead Log
Write-Ahead Logging - сначала записывай в лог, потом меняй данные
Любое изменение БД сначала пишется в лог на диск, а уже потом применяется к памяти/файлам
(На случай отключения света)
WAL это просто поток байт и хорошо ложится на Read/Write
===
Журналы только для добавления записей(Append-only logs)
Как и текстовые журналы, журнал базы данных только добавляет записи в конец файла и никогда не изменяет и не удаляет существующие записи. 
Записи журнала фиксируют каждое обновление базы данных. 
Например, журнал с 4 записями:
состояние операции
0                  {}
1 установить k1=x  {k1=x}
2 установить k2=y  {k1=x, k2=y}
3 установить k1=z  {k1=z, k2=y}
4 удалить k2       {k1=z}

При запуске базы данных она считывает журнал и применяет обновления по порядку, создавая конечное состояние {k1=z}. Это реализует инкрементальные обновления.
Когда журнал достигает определенного размера, он объединяется с основной структурой данных (LSM-дерево или B+дерево).
Журнал записывает каждое изменение состояния. Даже при параллельных транзакциях, если это не распределенная система, изменения состояния могут сериализоваться в журнале. Таким образом, журналы можно использовать для репликации и отката (отмены). Однако журнал не может расти бесконечно, поэтому он не может быть основным хранилищем и является лишь вспомогательным. Журнал не является строго обязательным; базу данных также можно построить на основе структур данных с механизмом копирования при записи, обладающих поведением, подобным журналу.
===
Обновляем 
pub struct Entry {
    key: Vec<u8>,
    val: Vec<u8>,
    deleted: bool,
}
под новфй фомат данных
| key_len | val_len | deleted | key | val |
| 4 байта | 4 байта | 1 байт  | ... | ... |
----
w.write_all(&[self.deleted as u8])?;
bool as u8 -> false = 0, true = 1
всегда ровно 1 байт
===
Read and write the log file
При запуске базы данных она многократно вызывает Log.Read() до конца файла. После этого каждое обновление вызывает Log.Write() для добавления данных в конец файла.
---
Log это обёртка над файлом:
- (Write)дописывает новые записи в конец файла
- (Read)читает записи по порядку с начала файла
---
если Decode вернул io.EOF(конец файла)
- иначе ошибка
- иначе запись прочитана
Ключевая идея EOF:
```rust
Err(e) if e.kind() == io::ErrorKind::UnexpectedEof
```
просто прокидывать ошибку наверх, а Log::read её разрулит.
---
при старте БД
```rust
let mut log = Log::open("wal.log")?;

while let Some(entry) = log.read()? {
    // применяем запись к in-memory структурам
}
```
---

## 8. Тесты (очень важно)

### 8.1 Тест: записали → прочитали

```rust
#[test]
fn log_write_then_read() {
    let dir = tempfile::tempdir().unwrap();
    let path = dir.path().join("wal.log");

    let mut log = Log::open(&path).unwrap();

    let e1 = Entry {
        key: b"a".to_vec(),
        val: b"1".to_vec(),
    };

    let e2 = Entry {
        key: b"b".to_vec(),
        val: b"2".to_vec(),
    };

    log.write(&e1).unwrap();
    log.write(&e2).unwrap();

    // читаем с начала
    log.fp.seek(std::io::SeekFrom::Start(0)).unwrap();

    let r1 = log.read().unwrap().unwrap();
    let r2 = log.read().unwrap().unwrap();
    let r3 = log.read().unwrap();

    assert_eq!(r1.key, b"a");
    assert_eq!(r2.key, b"b");
    assert!(r3.is_none());
}
```

---

## 9. Почему всё это круто

* `Entry` — чистая сериализация
* `Log` — чистый IO
* тесты:

  * через `Cursor<Vec<u8>>`
  * через реальный файл
* один и тот же код работает:

  * для WAL
  * для snapshot
  * для сетевого стрима

---

## 10. Ментальная модель (очень важно запомнить)

> **Entry не знает, где он живёт**
> **Log не знает, что внутри Entry**
> **Read / Write — контракт между ними**

