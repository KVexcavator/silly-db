WAL — Write-Ahead Log
Write-Ahead Logging - сначала записывай в лог, потом меняй данные
Любое изменение БД сначала пишется в лог на диск, а уже потом применяется к памяти/файлам
(На случай отключения света)
WAL это просто поток байт и хорошо ложится на Read/Write
===
Журналы только для добавления записей(Append-only logs)
Как и текстовые журналы, журнал базы данных только добавляет записи в конец файла и никогда не изменяет и не удаляет существующие записи. 
Записи журнала фиксируют каждое обновление базы данных. 
Например, журнал с 4 записями:
состояние операции
0                  {}
1 установить k1=x  {k1=x}
2 установить k2=y  {k1=x, k2=y}
3 установить k1=z  {k1=z, k2=y}
4 удалить k2       {k1=z}

При запуске базы данных она считывает журнал и применяет обновления по порядку, создавая конечное состояние {k1=z}. Это реализует инкрементальные обновления.
Когда журнал достигает определенного размера, он объединяется с основной структурой данных (LSM-дерево или B+дерево).
Журнал записывает каждое изменение состояния. Даже при параллельных транзакциях, если это не распределенная система, изменения состояния могут сериализоваться в журнале. Таким образом, журналы можно использовать для репликации и отката (отмены). Однако журнал не может расти бесконечно, поэтому он не может быть основным хранилищем и является лишь вспомогательным. Журнал не является строго обязательным; базу данных также можно построить на основе структур данных с механизмом копирования при записи, обладающих поведением, подобным журналу.
===
Обновляем 
pub struct Entry {
    key: Vec<u8>,
    val: Vec<u8>,
    deleted: bool,
}
под новфй фомат данных
| key_len | val_len | deleted | key | val |
| 4 байта | 4 байта | 1 байт  | ... | ... |
----
w.write_all(&[self.deleted as u8])?;
bool as u8 -> false = 0, true = 1
всегда ровно 1 байт
===
Read and write the log file
При запуске базы данных она многократно вызывает Log.Read() до конца файла. После этого каждое обновление вызывает Log.Write() для добавления данных в конец файла.
---
Log это обёртка над файлом:
- (Write)дописывает новые записи в конец файла
- (Read)читает записи по порядку с начала файла
---
если Decode вернул io.EOF(конец файла)
- иначе ошибка
- иначе запись прочитана
Ключевая идея EOF:
```rust
Err(e) if e.kind() == io::ErrorKind::UnexpectedEof
```
просто прокидывать ошибку наверх, а Log::read её разрулит.
---
при старте БД
```rust
let mut log = Log::open("wal.log")?;

while let Some(entry) = log.read()? {
    // применяем запись к in-memory структурам
}
```
===
tombstone надгробный камень
tombstone это логическое удаление
Обязательен потому что нельзя просто удалить ключ:
WAL - только для добавления
старые set всё ещё в логе при replay они воскреснут
===
при старте БД
мы читаем WAL с начала до EOF
каждую запись применяем к mem
если ключ встречается несколько раз → последняя запись побеждает
если запись deleted, ключ удаляется
WAL = источник истины, mem = кэш текущего состояния
---
В Rust KeyValue должен знать, где лог:
```rust
pub struct KV {
    log: Log,
    mem: HashMap<Vec<u8>, Vec<u8>>,
}
```
И open должен принимать путь:
```rust
pub fn open(path: impl Into<PathBuf>) -> Result<Self, KVError>
```
---
Почему последняя запись побеждает работает автоматически
```rust
mem.insert(key, value);
```
Если ключ уже есть:
старое значение перезаписывается
именно этого требует условие
Сначала пишем в WAL, потом меняем память
---
